{
  "$schema": "https://pitsiui.com/schema/registry-item.json",
  "name": "bg-guides",
  "type": "registry:ui",
  "description": "Animated background guide lines with glow effects.",
  "dependencies": [
    "motion/react",
    "next-themes"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/ui/bg-guides.tsx",
      "content": "\"use client\"\n\nimport React, { useCallback, useEffect, useMemo, useState } from \"react\"\nimport { AnimatePresence, motion } from \"motion/react\"\nimport { useTheme } from \"next-themes\"\n\ntype AnimationDirection = \"top-to-bottom\" | \"bottom-to-top\" | \"both\" | \"random\"\ntype AnimationEasing = \"linear\" | \"easeIn\" | \"easeOut\" | \"easeInOut\" | \"spring\"\n\ninterface AnimatedBackgroundGuidesProps {\n  columnCount?: number\n  className?: string\n  solidLines?: number[]\n  hiddenLines?: number[]\n  animated?: boolean\n  animationDuration?: number\n  animationDelay?: number\n  glowColor?: string\n  glowSize?: string\n  glowOpacity?: number\n  randomize?: boolean\n  randomInterval?: number\n  direction?: AnimationDirection\n  easing?: AnimationEasing\n  responsive?: boolean\n  minColumnWidth?: string\n  maxActiveColumns?: number\n  darkMode?: boolean\n  contained?: boolean\n  zIndex?: number\n}\n\nconst easingFunctions = {\n  linear: [0, 0, 1, 1] as const,\n  easeIn: [0.42, 0, 1, 1] as const,\n  easeOut: [0, 0, 0.58, 1] as const,\n  easeInOut: [0.42, 0, 0.58, 1] as const,\n  spring: [0.175, 0.885, 0.32, 1.275] as const,\n}\n\nexport function StripeBgGuides({\n  columnCount = 4,\n  className = \"\",\n  solidLines = [],\n  hiddenLines = [], // Add hiddenLines here\n  animated = true,\n  animationDuration = 62,\n  animationDelay = 0.8,\n  glowColor = \"hsl(var(--accent))\",\n  //   glowColor = \"#D2F583\",\n  glowSize = \"10vh\",\n  glowOpacity = 0.4,\n  randomize = true,\n  randomInterval = 9000,\n  direction = \"both\",\n  easing = \"spring\",\n  responsive = false,\n  minColumnWidth = \"4rem\",\n  maxActiveColumns = 3,\n  darkMode: darkModeProp,\n  contained = false,\n  zIndex,\n}: AnimatedBackgroundGuidesProps) {\n  const { resolvedTheme } = useTheme()\n  const darkMode = darkModeProp ?? resolvedTheme === \"dark\"\n\n  const [windowWidth, setWindowWidth] = useState(\n    typeof window !== \"undefined\" ? window.innerWidth : 0\n  )\n\n  const columnCount_ = useMemo(() => {\n    return responsive\n      ? Math.max(Math.floor(windowWidth / parseInt(minColumnWidth)), 1)\n      : columnCount\n  }, [columnCount, responsive, windowWidth, minColumnWidth])\n\n  const getRandomColumns = useCallback(() => {\n    const newActiveColumns = Array.from(\n      { length: columnCount_ },\n      () => Math.random() < 0.5\n    )\n    const activeCount = newActiveColumns.filter(Boolean).length\n    if (activeCount > maxActiveColumns) {\n      const indicesToDeactivate = newActiveColumns\n        .map((isActive, index) => (isActive ? index : -1))\n        .filter((index) => index !== -1)\n        .sort(() => Math.random() - 0.5)\n        .slice(0, activeCount - maxActiveColumns)\n      indicesToDeactivate.forEach((index) => {\n        newActiveColumns[index] = false\n      })\n    }\n    return newActiveColumns\n  }, [columnCount_, maxActiveColumns])\n\n  // Derive active columns - all true by default, or randomized if animated\n  const activeColumns = useMemo(() => {\n    if (randomize && animated) {\n      return getRandomColumns()\n    }\n    return Array.from({ length: columnCount_ }, () => true)\n  }, [columnCount_, randomize, animated, getRandomColumns])\n\n  // State for randomized columns (only used when randomize && animated)\n  const [randomizedColumns, setRandomizedColumns] = useState<boolean[] | null>(\n    null\n  )\n\n  useEffect(() => {\n    const handleResize = () => setWindowWidth(window.innerWidth)\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"resize\", handleResize)\n      return () => window.removeEventListener(\"resize\", handleResize)\n    }\n  }, [])\n\n  useEffect(() => {\n    if (!randomize || !animated) {\n      return\n    }\n\n    setRandomizedColumns(getRandomColumns())\n    const intervalId = setInterval(() => {\n      setRandomizedColumns(getRandomColumns())\n    }, randomInterval)\n\n    return () => {\n      clearInterval(intervalId)\n      setRandomizedColumns(null)\n    }\n  }, [randomize, animated, randomInterval, getRandomColumns])\n\n  // Use randomized columns if available, otherwise use derived active columns\n  const finalActiveColumns = randomizedColumns ?? activeColumns\n\n  const getAnimationVariants = useCallback(() => {\n    const variants = {\n      \"top-to-bottom\": {\n        initial: { top: \"-100%\" },\n        animate: { top: \"100%\" },\n      },\n      \"bottom-to-top\": {\n        initial: { top: \"100%\" },\n        animate: { top: \"-100%\" },\n      },\n      both: {\n        initial: { top: \"100%\" },\n        animate: { top: [\"-100%\", \"100%\"] },\n      },\n      random: {\n        initial: () => ({ top: Math.random() < 0.5 ? \"-100%\" : \"100%\" }),\n        animate: () => ({ top: Math.random() < 0.5 ? \"-100%\" : \"100%\" }),\n      },\n    }\n    return variants[direction] || variants[\"top-to-bottom\"]\n  }, [direction])\n\n  const animationVariants = useMemo(\n    () => getAnimationVariants(),\n    [getAnimationVariants]\n  )\n\n  const isMobile = windowWidth > 0 && windowWidth < 768\n\n  const lineColors = useMemo(() => {\n    // Reduce opacity on mobile\n    const mobileMultiplier = isMobile ? 0.6 : 1\n\n    return {\n      // Dark mode: white lines with lower opacity, Light mode: darker lines\n      solid: darkMode\n        ? `hsla(0 0% 100% / ${(0.06 * mobileMultiplier).toFixed(2)})`\n        : `hsla(220 10% 40% / ${(0.3 * mobileMultiplier).toFixed(2)})`,\n      dashed: darkMode\n        ? `hsla(0 0% 100% / ${(0.06 * mobileMultiplier).toFixed(2)})`\n        : `hsla(220 10% 40% / ${(0.3 * mobileMultiplier).toFixed(2)})`,\n    }\n  }, [darkMode, isMobile])\n\n  // Calculate line positions for CSS Grid with gap-6 (1.5rem = 24px)\n  // Line at position i (1-5): calc(i * (100% + 1.5rem) / 6) - at column left edges\n  const getLinePosition = (index: number): string => {\n    if (index === 0) return \"0\"\n    if (index === columnCount_) return \"100%\"\n    return `calc(${index} * (100% + 1.5rem) / 6)`\n  }\n\n  return (\n    <div\n      className={`pointer-events-none ${\n        contained ? \"absolute inset-0\" : \"fixed inset-0\"\n      } ${className}`}\n      aria-hidden=\"true\"\n      style={{ zIndex: zIndex ?? (contained ? 25 : -1) }}\n    >\n      <div className=\"relative z-0 container h-full w-full px-6\">\n        <div className=\"relative grid h-full grid-cols-6 gap-6\">\n          {[...Array(columnCount_ + 1)].map((_, index) => {\n            if (hiddenLines.includes(index + 1)) {\n              return null // Skip rendering this line\n            }\n            return (\n              <div\n                key={index}\n                className=\"absolute inset-y-0 w-px overflow-hidden\"\n                style={{\n                  left: getLinePosition(index),\n                  ...(solidLines.includes(index + 1)\n                    ? { background: lineColors.solid }\n                    : {\n                        backgroundImage: `linear-gradient(to bottom, ${lineColors.dashed} 50%, transparent 50%)`,\n                        backgroundSize: \"1px 8px\",\n                      }),\n                }}\n              >\n                <AnimatePresence>\n                  {animated && finalActiveColumns[index] && (\n                    <motion.div\n                      key={`glow-${index}`}\n                      className=\"absolute w-full\"\n                      style={{\n                        height: glowSize,\n                        background: `linear-gradient(to bottom, transparent, ${glowColor}, ${\n                          darkMode ? \"white\" : \"black\"\n                        })`,\n                        opacity: glowOpacity,\n                      }}\n                      initial={\n                        typeof animationVariants.initial === \"function\"\n                          ? animationVariants.initial()\n                          : animationVariants.initial\n                      }\n                      animate={\n                        typeof animationVariants.animate === \"function\"\n                          ? animationVariants.animate()\n                          : animationVariants.animate\n                      }\n                      exit={\n                        typeof animationVariants.initial === \"function\"\n                          ? animationVariants.initial()\n                          : animationVariants.initial\n                      }\n                      transition={{\n                        duration: animationDuration,\n                        repeat: Infinity,\n                        ease: easingFunctions[easing],\n                        delay: index * animationDelay,\n                      }}\n                    />\n                  )}\n                </AnimatePresence>\n              </div>\n            )\n          })}\n        </div>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    }
  ],
  "categories": [
    "sectorial"
  ],
  "tier": "free",
  "readiness": "production"
}