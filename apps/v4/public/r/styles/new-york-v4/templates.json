{
  "$schema": "https://pitsiui.com/schema/registry-item.json",
  "name": "templates",
  "type": "registry:lib",
  "description": "Runtime template helpers for blocks-first architecture with block selection utilities.",
  "registryDependencies": [
    "palettes",
    "typography"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/lib/templates.ts",
      "content": "// Runtime template helpers for blocks-first architecture\n// Re-exports computed templates from __blocks-metadata__.ts and provides utilities\n\nimport {\n  COMPUTED_TEMPLATES,\n  getAllComputedTemplates,\n  getBlocksByTemplateAndType,\n  getComputedTemplate,\n  type ComputedTemplate,\n  type ComputedTemplateBlock,\n} from \"@/registry/__blocks-metadata__\"\n\n// Re-export types and data\nexport type { ComputedTemplate, ComputedTemplateBlock }\nexport {\n  COMPUTED_TEMPLATES,\n  getComputedTemplate,\n  getAllComputedTemplates,\n  getBlocksByTemplateAndType,\n}\n\n/**\n * Get the list of block types that have alternatives (more than one block)\n * Used to determine which block types need toggle UI\n */\nexport function getBlockTypesWithAlternatives(templateSlug: string): string[] {\n  const template = COMPUTED_TEMPLATES[templateSlug]\n  if (!template) return []\n\n  return Object.entries(template.blockGroups)\n    .filter(([_, blocks]) => blocks.length > 1)\n    .map(([blockType]) => blockType)\n}\n\n/**\n * Get the default selected blocks for a template\n * Returns the first block of each type as the default selection\n */\nexport function getDefaultBlockSelections(\n  templateSlug: string\n): Record<string, string> {\n  const template = COMPUTED_TEMPLATES[templateSlug]\n  if (!template) return {}\n\n  const selections: Record<string, string> = {}\n\n  for (const [blockType, blocks] of Object.entries(template.blockGroups)) {\n    if (blocks.length > 0) {\n      selections[blockType] = blocks[0]\n    }\n  }\n\n  return selections\n}\n\n/**\n * Get the blocks to render for a template given the current selections\n * Returns blocks in order, using the selected block for each type\n */\nexport function getSelectedTemplateBlocks(\n  templateSlug: string,\n  selections: Record<string, string>\n): ComputedTemplateBlock[] {\n  const template = COMPUTED_TEMPLATES[templateSlug]\n  if (!template) return []\n\n  // Build a map of which blocks are selected for each type\n  const selectedBlockNames = new Set(Object.values(selections))\n\n  // For types with only one block, that block is automatically selected\n  for (const [blockType, blocks] of Object.entries(template.blockGroups)) {\n    if (blocks.length === 1) {\n      selectedBlockNames.add(blocks[0])\n    }\n  }\n\n  // If a type has multiple blocks but no selection, use the first one\n  for (const [blockType, blocks] of Object.entries(template.blockGroups)) {\n    if (blocks.length > 1 && !selections[blockType]) {\n      selectedBlockNames.add(blocks[0])\n    }\n  }\n\n  // Filter and dedupe blocks, keeping only selected ones\n  // We need to handle the case where multiple blocks of same type exist\n  const seenTypes = new Set<string>()\n  const result: ComputedTemplateBlock[] = []\n\n  for (const block of template.blocks) {\n    // Skip if we already have a block of this type\n    if (seenTypes.has(block.blockType)) continue\n\n    // If this is the selected block for its type\n    if (selectedBlockNames.has(block.name)) {\n      result.push(block)\n      seenTypes.add(block.blockType)\n    }\n  }\n\n  return result\n}\n\n/**\n * Get the config for a specific block by name\n */\nexport function getBlockConfig(\n  templateSlug: string,\n  blockName: string\n): ComputedTemplateBlock | null {\n  const template = COMPUTED_TEMPLATES[templateSlug]\n  if (!template) return null\n\n  return template.blocks.find((b) => b.name === blockName) || null\n}\n\n/**\n * Get all template slugs\n */\nexport function getAllTemplateSlugs(): string[] {\n  return Object.keys(COMPUTED_TEMPLATES)\n}\n\n/**\n * Get templates by type\n */\nexport function getTemplatesByType(\n  type: \"service\" | \"application\"\n): ComputedTemplate[] {\n  return getAllComputedTemplates().filter((t) => t.type === type)\n}\n\n/**\n * Check if a template uses a specific palette\n */\nexport function templateUsesPalette(\n  templateSlug: string,\n  palette: string\n): boolean {\n  const template = COMPUTED_TEMPLATES[templateSlug]\n  return template?.palette === palette\n}\n\n/**\n * Check if a template uses a specific typography preset\n */\nexport function templateUsesTypography(\n  templateSlug: string,\n  typography: string\n): boolean {\n  const template = COMPUTED_TEMPLATES[templateSlug]\n  return template?.typography === typography\n}\n",
      "type": "registry:lib"
    }
  ],
  "readiness": "production"
}