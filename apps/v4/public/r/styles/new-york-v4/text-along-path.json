{
  "$schema": "https://pitsiui.com/schema/registry-item.json",
  "name": "text-along-path",
  "type": "registry:ui",
  "description": "Text that follows an SVG path on scroll.",
  "dependencies": [
    "motion/react"
  ],
  "registryDependencies": [
    "utils",
    "use-animation-state"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/animations/text-along-path/text-along-path.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport { createContext, memo, useContext, useMemo, useRef } from \"react\"\nimport { motion, MotionValue, useScroll, useTransform } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { useAnimationState } from \"@/hooks/use-animation-state\"\n\n// Context for scroll progress\nconst ScrollPathContext = createContext<MotionValue<number> | null>(null)\n\nexport type ScrollPathContainerProps = {\n  /** Container children */\n  children: ReactNode\n  /** Additional CSS classes */\n  className?: string\n  /** Container height. Default: \"350vh\" */\n  height?: string\n  /** Enable scroll-based animation. Default: true */\n  scrollBased?: boolean\n  /** Disable animation on mobile. Default: false */\n  noMobile?: boolean\n}\n\n/**\n * Container for scroll-animated path effects.\n * Provides scroll progress to child ScrollLinePath components.\n */\nexport const ScrollPathContainer = memo<ScrollPathContainerProps>(\n  ({\n    children,\n    className,\n    height = \"350vh\",\n    scrollBased = true,\n    noMobile = false,\n  }) => {\n    const ref = useRef<HTMLDivElement>(null)\n    const { shouldUseScroll, shouldDisableAnimation } = useAnimationState(\n      scrollBased,\n      noMobile\n    )\n\n    const { scrollYProgress } = useScroll({\n      target: shouldUseScroll ? ref : undefined,\n    })\n\n    if (shouldDisableAnimation) {\n      return (\n        <section\n          className={cn(\n            \"flex flex-col items-center overflow-hidden\",\n            className\n          )}\n          style={{ height }}\n        >\n          {children}\n        </section>\n      )\n    }\n\n    return (\n      <ScrollPathContext.Provider value={scrollYProgress}>\n        <section\n          ref={ref}\n          className={cn(\n            \"flex flex-col items-center overflow-hidden\",\n            className\n          )}\n          style={{ height }}\n        >\n          {children}\n        </section>\n      </ScrollPathContext.Provider>\n    )\n  }\n)\n\nScrollPathContainer.displayName = \"ScrollPathContainer\"\n\nexport type ScrollLinePathProps = {\n  /** SVG path data (d attribute) */\n  path: string\n  /** Additional CSS classes for the SVG */\n  className?: string\n  /** Stroke color. Default: \"#C2F84F\" */\n  strokeColor?: string\n  /** Stroke width. Default: 20 */\n  strokeWidth?: number\n  /** ViewBox dimensions. Default: \"0 0 1278 2319\" */\n  viewBox?: string\n  /** Initial path progress (0-1). Default: 0.5 */\n  initialProgress?: number\n  /** Enable scroll-based animation. Default: true */\n  scrollBased?: boolean\n  /** Disable animation on mobile. Default: false */\n  noMobile?: boolean\n}\n\n/**\n * SVG path that animates its stroke based on scroll progress.\n * Use inside ScrollPathContainer.\n */\nexport const ScrollLinePath = memo<ScrollLinePathProps>(\n  ({\n    path,\n    className,\n    strokeColor = \"#C2F84F\",\n    strokeWidth = 20,\n    viewBox = \"0 0 1278 2319\",\n    initialProgress = 0.5,\n    scrollBased = true,\n    noMobile = false,\n  }) => {\n    const context = useContext(ScrollPathContext)\n    const { shouldDisableAnimation } = useAnimationState(scrollBased, noMobile)\n\n    const pathLength = useTransform(\n      context || new MotionValue(0),\n      [0, 1],\n      [initialProgress, 1]\n    )\n\n    const strokeDashoffset = useTransform(pathLength, (value) => 1 - value)\n\n    if (shouldDisableAnimation || !context) {\n      return (\n        <svg\n          viewBox={viewBox}\n          fill=\"none\"\n          overflow=\"visible\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          className={className}\n        >\n          <path d={path} stroke={strokeColor} strokeWidth={strokeWidth} />\n        </svg>\n      )\n    }\n\n    return (\n      <svg\n        viewBox={viewBox}\n        fill=\"none\"\n        overflow=\"visible\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        className={className}\n      >\n        <motion.path\n          d={path}\n          stroke={strokeColor}\n          strokeWidth={strokeWidth}\n          style={{\n            pathLength,\n            strokeDashoffset,\n          }}\n        />\n      </svg>\n    )\n  }\n)\n\nScrollLinePath.displayName = \"ScrollLinePath\"\n\n// Original curved text components\nexport type CurvedTextProps = {\n  /** Text to display along the curve */\n  text: string\n  /** Additional CSS classes for container */\n  className?: string\n  /** Additional CSS classes for text styling */\n  textClassName?: string\n  /** Type of curve. Default: \"arc\" */\n  curve?: \"arc\" | \"wave\" | \"circle\"\n  /** Disable animation features. Default: false */\n  noMobile?: boolean\n}\n\n/**\n * Text that follows predefined curved paths.\n * Choose from arc, wave, or circle curves for decorative text layouts.\n */\nexport const CurvedText = memo<CurvedTextProps>(\n  ({ text, className, textClassName, curve = \"arc\", noMobile = false }) => {\n    const { shouldDisableAnimation } = useAnimationState(false, noMobile)\n\n    const paths = useMemo(\n      () => ({\n        arc: \"M 100 400 Q 500 100 900 400\",\n        wave: \"M 100 250 Q 250 100 400 250 T 700 250 T 900 250\",\n        circle: \"M 500 100 A 300 300 0 1 1 500 100.001\",\n      }),\n      []\n    )\n\n    const pathId = useMemo(\n      () => `${curve}-path-${Math.random().toString(36).slice(2, 9)}`,\n      [curve]\n    )\n\n    if (shouldDisableAnimation) {\n      return (\n        <div className={cn(\"text-center\", className)}>\n          <p className={cn(\"text-4xl font-bold\", textClassName)}>{text}</p>\n        </div>\n      )\n    }\n\n    return (\n      <div className={className}>\n        <svg\n          viewBox=\"0 0 1000 500\"\n          className=\"w-full\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <defs>\n            <path id={pathId} d={paths[curve]} fill=\"none\" />\n          </defs>\n\n          <text\n            className={cn(\"fill-current text-4xl font-bold\", textClassName)}\n          >\n            <textPath href={`#${pathId}`} startOffset=\"50%\" textAnchor=\"middle\">\n              {text}\n            </textPath>\n          </text>\n        </svg>\n      </div>\n    )\n  }\n)\n\nCurvedText.displayName = \"CurvedText\"\n\nexport type CircularTextProps = {\n  /** Text to display in circular arrangement */\n  text: string\n  /** Additional CSS classes for container */\n  className?: string\n  /** Additional CSS classes for text styling */\n  textClassName?: string\n  /** Radius of the circle in pixels. Default: 200 */\n  radius?: number\n  /** Enable scroll-based rotation. Default: false */\n  rotate?: boolean\n  /** Enable scroll-based animation. Default: true (when rotate is true) */\n  scrollBased?: boolean\n  /** Disable animation on mobile. Default: false */\n  noMobile?: boolean\n}\n\n/**\n * Text arranged in a circle with optional scroll-based rotation.\n * Perfect for logos, badges, and decorative elements.\n */\nexport const CircularText = memo<CircularTextProps>(\n  ({\n    text,\n    className,\n    textClassName,\n    radius = 200,\n    rotate = false,\n    scrollBased = true,\n    noMobile = false,\n  }) => {\n    const ref = useRef<HTMLDivElement>(null)\n    const { shouldDisableAnimation, shouldUseScroll } = useAnimationState(\n      scrollBased && rotate,\n      noMobile\n    )\n\n    const { scrollYProgress } = useScroll({\n      target: shouldUseScroll ? ref : undefined,\n      offset: [\"start end\", \"end start\"],\n    })\n\n    const rotation = useTransform(scrollYProgress, [0, 1], [0, 360])\n\n    const pathId = useMemo(\n      () => `circle-path-${Math.random().toString(36).slice(2, 9)}`,\n      []\n    )\n\n    const center = 250\n\n    const circularPath = useMemo(\n      () =>\n        `M ${center} ${center - radius} A ${radius} ${radius} 0 1 1 ${center - 0.001} ${center - radius}`,\n      [radius, center]\n    )\n\n    if (shouldDisableAnimation && rotate) {\n      return (\n        <div className={cn(\"text-center\", className)}>\n          <p\n            className={cn(\n              \"text-2xl font-bold tracking-wider uppercase\",\n              textClassName\n            )}\n          >\n            {text}\n          </p>\n        </div>\n      )\n    }\n\n    return (\n      <div ref={ref} className={className}>\n        <svg\n          viewBox=\"0 0 500 500\"\n          className=\"w-full\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <defs>\n            <path id={pathId} d={circularPath} fill=\"none\" />\n          </defs>\n\n          <motion.g\n            style={\n              rotate && !shouldDisableAnimation\n                ? ({\n                    rotate: rotation,\n                    originX: \"250px\",\n                    originY: \"250px\",\n                  } as any)\n                : undefined\n            }\n          >\n            <text\n              className={cn(\n                \"fill-current text-2xl font-bold tracking-wider uppercase\",\n                textClassName\n              )}\n            >\n              <textPath href={`#${pathId}`} startOffset=\"0%\">\n                {text}\n              </textPath>\n            </text>\n          </motion.g>\n        </svg>\n      </div>\n    )\n  }\n)\n\nCircularText.displayName = \"CircularText\"\n\nexport default ScrollPathContainer\n",
      "type": "registry:ui"
    }
  ],
  "categories": [
    "animations"
  ],
  "tier": "free",
  "readiness": "beta"
}