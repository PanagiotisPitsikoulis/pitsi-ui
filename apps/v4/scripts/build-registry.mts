import { exec, execFile } from "child_process"
import { existsSync, promises as fs } from "fs"
import path from "path"
import { rimraf } from "rimraf"
import { glob } from "glob"
import { registrySchema, type RegistryItem } from "pitsi/schema"

import { STYLES, type Style } from "@/registry/styles"

// Inline getAllBlocks to avoid circular dependency with __blocks-metadata__
async function getAllBlocks(types: string[] = ["registry:block"]): Promise<RegistryItem[]> {
  const items: RegistryItem[] = []

  for (const style of STYLES) {
    const { registry: importedRegistry } = await import(
      `../registry/${style.name}/registry.ts`
    )
    const parseResult = registrySchema.safeParse(importedRegistry)
    if (!parseResult.success) continue

    for (const item of parseResult.data.items) {
      if (types.includes(item.type)) {
        items.push(item as RegistryItem)
      }
    }
  }

  return items
}

async function generateRegistryFromConfigs(styleName: string) {
  const baseDir = path.join(process.cwd(), `registry/${styleName}`)
  const configPattern = `${baseDir}/blocks/**/*.config.ts`
  const configFiles = await glob(configPattern)

  console.log(`  Found ${configFiles.length} config files`)

  const items: Array<Record<string, unknown>> = []

  for (const configPath of configFiles) {
    try {
      const mod = await import(configPath)
      const config = mod.registryConfig

      if (!config) {
        console.warn(`  Warning: No registryConfig export in ${configPath}`)
        continue
      }

      // Infer component path from config path
      const relativePath = configPath
        .replace(baseDir + "/", "")
        .replace(".config.ts", ".tsx")

      items.push({
        ...config,
        files: [{ path: relativePath, type: config.type }],
      })
    } catch (err) {
      console.error(`  Error loading ${configPath}:`, err)
    }
  }

  // Sort alphabetically for consistent output
  items.sort((a, b) => (a.name as string).localeCompare(b.name as string))

  // Generate _registry.ts content
  const output = `// AUTO-GENERATED by scripts/build-registry.mts
// Do not edit this file directly.
import { Registry } from "pitsi/schema"

export interface BlockConfig {
  template: string
  blockType: string
  order: number
  palette: string
  typography: string
  tint?: "base" | "tinted" | "deep"
  forceLight?: boolean
  forceDark?: boolean
}

export const blocks: Registry["items"] = ${JSON.stringify(items, null, 2)}
`

  const outputPath = path.join(baseDir, "blocks/_registry.ts")
  await fs.writeFile(outputPath, output)

  // Format with prettier
  await new Promise<void>((resolve, reject) => {
    execFile("prettier", ["--write", outputPath], (error) => {
      if (error) reject(error)
      else resolve()
    })
  })

  console.log(`  Generated ${outputPath} with ${items.length} blocks`)
}

async function buildRegistryIndex(styles: Style[]) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, Record<string, any>> = {`

  for (const style of styles) {
    // Dynamically import the registry for this style.
    const { registry: importedRegistry } = await import(
      `../registry/${style.name}/registry.ts`
    )

    // Validate the registry schema.
    const parseResult = registrySchema.safeParse(importedRegistry)
    if (!parseResult.success) {
      console.error(`‚ùå Registry validation failed for ${style.name}:`)
      console.error(parseResult.error.format())
      throw new Error(`Invalid registry schema for ${style.name}`)
    }

    const registry = parseResult.data

    index += `
  "${style.name}": {`

    for (const item of registry.items) {
      const files =
        item.files?.map((file) => ({
          path: typeof file === "string" ? file : file.path,
          type: typeof file === "string" ? item.type : file.type,
          target: typeof file === "string" ? undefined : file.target,
        })) ?? []

      if (files.length === 0) {
        continue
      }

      const componentPath = item.files?.[0]?.path
        ? `@/registry/${style.name}/${item.files[0].path}`
        : ""

      index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${files.map((file) => {
        const filePath = `registry/${style.name}/${file.path}`
        return `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`
      })}],
      component: ${
        componentPath
          ? `React.lazy(async () => {
        const mod = await import("${componentPath}")
        const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || "${item.name}"
        return { default: mod.default || mod[exportName] }
      })`
          : "null"
      },
      categories: ${JSON.stringify(item.categories)},
      meta: ${JSON.stringify(item.meta)},
      tier: ${JSON.stringify(item.tier)},
      readiness: ${JSON.stringify(item.readiness)},
    },`
    }

    index += `
  },`
  }

  index += `
}`

  console.log(
    `#Ô∏è‚É£  Built multi-style index with ${styles.length} styles: ${styles.map((s) => s.name).join(", ")}`
  )

  // Write unified index.
  rimraf.sync(path.join(process.cwd(), "registry/__index__.tsx"))
  await fs.writeFile(path.join(process.cwd(), "registry/__index__.tsx"), index)
}

async function buildRegistryJsonFile(styleName: string) {
  // 1. Import the registry for this style.
  const { registry: importedRegistry } = await import(
    `../registry/${styleName}/registry.ts`
  )

  // 2. Validate the registry schema.
  const parseResult = registrySchema.safeParse(importedRegistry)
  if (!parseResult.success) {
    console.error(`‚ùå Registry validation failed for ${styleName}:`)
    console.error(parseResult.error.format())
    throw new Error(`Invalid registry schema for ${styleName}`)
  }

  const registry = parseResult.data

  // 3. Fix the path for registry items.
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => {
      const files = item.files?.map((file) => {
        return {
          ...file,
          path: `registry/${styleName}/${file.path}`,
        }
      })

      return {
        ...item,
        files,
      }
    }),
  }

  // 3. Create the output directory and write registry.json.
  const outputDir = path.join(
    process.cwd(),
    styleName === "new-york-v4" ? `public/r/styles/${styleName}` : `public/r/${styleName}`
  )
  await fs.mkdir(outputDir, { recursive: true })

  // 4. Write registry.json to output directory and format it.
  const registryJsonPath = path.join(outputDir, "registry.json")
  await fs.writeFile(registryJsonPath, JSON.stringify(fixedRegistry, null, 2))
  await new Promise<void>((resolve, reject) => {
    execFile('prettier', ['--write', registryJsonPath], (error) => {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  })

  // 5. Write temporary registry file needed by pitsi build.
  const tempRegistryPath = path.join(process.cwd(), `registry-${styleName}.json`)
  await fs.writeFile(tempRegistryPath, JSON.stringify(fixedRegistry, null, 2))
}

async function buildRegistry(styleName: string) {
  return new Promise((resolve, reject) => {
    // Use local pitsi copy.
    const outputPath =
      styleName === "new-york-v4" ? `public/r/styles/${styleName}` : `public/r/${styleName}`
    const process = exec(
      `node ../../packages/pitsi/dist/index.js build registry-${styleName}.json --output ${outputPath}`
    )

    // exec(
    //   `pnpm dlx pitsi build registry-${styleName}.json --output public/r/styles/${styleName}`
    // )

    process.on("exit", (code) => {
      if (code === 0) {
        resolve(undefined)
      } else {
        reject(new Error(`Process exited with code ${code}`))
      }
    })
  })
}

async function buildBlocksIndex() {
  const blocks = await getAllBlocks(["registry:block"])

  const payload = blocks.map((block) => ({
    name: block.name,
    description: block.description,
    categories: block.categories,
  }))

  rimraf.sync(path.join(process.cwd(), "registry/__blocks__.json"))
  await fs.writeFile(
    path.join(process.cwd(), "registry/__blocks__.json"),
    JSON.stringify(payload, null, 2)
  )

  await exec(`prettier --write registry/__blocks__.json`)
}

// BlockConfig interface for type safety
interface BlockConfigType {
  template: string
  blockType: string
  order: number
  palette: string
  typography: string
  tint?: "base" | "tinted" | "deep"
  forceLight?: boolean
  forceDark?: boolean
}

// Computed template interfaces
interface ComputedTemplateBlockType {
  name: string
  blockType: string
  order: number
  palette: string
  typography: string
  tint?: "base" | "tinted" | "deep"
  forceLight?: boolean
  forceDark?: boolean
}

interface ComputedTemplateType {
  slug: string
  name: string
  description: string
  heroBlock: string
  type: "service" | "application"
  blocks: ComputedTemplateBlockType[]
  blockGroups: Record<string, string[]>
}

async function buildBlocksMetadata(styles: Style[]) {
  // Import template configs from _template-configs.ts
  const { templateConfigs } = await import(
    `../registry/new-york-v4/blocks/_template-configs.ts`
  )

  // Structure: { category: blockNames[] }
  const categoryStructure: Record<string, string[]> = {}

  // Build template metadata from template configs (not registry)
  const templateMetadata = templateConfigs.map((config: { slug: string; name: string; description: string; heroBlock: string; type: "service" | "application" }) => ({
    slug: config.slug,
    name: config.name,
    description: config.description,
    heroBlock: config.heroBlock,
    type: config.type,
  }))

  // Blocks-first: Collect blocks by template for computing templates
  const blocksByTemplate: Record<string, {
    block: ComputedTemplateBlockType
    description: string
    categories: string[]
  }[]> = {}

  for (const style of styles) {
    const { registry: importedRegistry } = await import(
      `../registry/${style.name}/registry.ts`
    )

    const parseResult = registrySchema.safeParse(importedRegistry)
    if (!parseResult.success) continue

    const registry = parseResult.data

    for (const item of registry.items) {
      if (item.type !== "registry:block" && item.type !== "registry:internal") {
        continue
      }

      // Use categories from registry entry directly
      const categories = item.categories || []
      if (categories.length === 0) continue

      // Skip "template" category - templates are no longer registry items
      if (categories.includes("template")) continue

      // Use the first category as the main category
      const mainCategory = categories[0]

      if (!categoryStructure[mainCategory]) {
        categoryStructure[mainCategory] = []
      }
      categoryStructure[mainCategory].push(item.name)

      // Collect blocks with blockConfig for template computation
      const blockConfig = (item as unknown as { blockConfig?: BlockConfigType }).blockConfig
      if (blockConfig && blockConfig.template && blockConfig.template !== "standalone") {
        if (!blocksByTemplate[blockConfig.template]) {
          blocksByTemplate[blockConfig.template] = []
        }
        blocksByTemplate[blockConfig.template].push({
          block: {
            name: item.name,
            blockType: blockConfig.blockType,
            order: blockConfig.order,
            palette: blockConfig.palette,
            typography: blockConfig.typography,
            tint: blockConfig.tint,
            forceLight: blockConfig.forceLight,
            forceDark: blockConfig.forceDark,
          },
          description: item.description || "",
          categories: categories,
        })
      }
    }
  }

  // Compute templates from template configs
  const computedTemplates: Record<string, ComputedTemplateType> = {}

  for (const config of templateConfigs) {
    const blockInfos = blocksByTemplate[config.slug] || []

    // Warn if no blocks found for this template
    if (blockInfos.length === 0) {
      console.warn(`  Warning: No blocks found for template "${config.slug}"`)
    }

    // Sort blocks by order
    const sortedBlocks = blockInfos.sort((a, b) => a.block.order - b.block.order)

    // Find the hero block (first block with blockType "hero" or "view")
    const heroBlockInfo = sortedBlocks.find(
      (b) => b.block.blockType === "hero" || b.block.blockType === "view"
    )

    // Group blocks by type for toggle UI
    const blockGroups: Record<string, string[]> = {}
    for (const blockInfo of sortedBlocks) {
      const blockType = blockInfo.block.blockType
      if (!blockGroups[blockType]) {
        blockGroups[blockType] = []
      }
      blockGroups[blockType].push(blockInfo.block.name)
    }

    computedTemplates[config.slug] = {
      slug: config.slug,
      name: config.name,
      description: config.description,
      heroBlock: heroBlockInfo?.block.name || config.heroBlock,
      type: config.type,
      blocks: sortedBlocks.map((b) => b.block),
      blockGroups,
    }
  }

  // Warn about orphan blocks (blocks referencing unknown templates)
  const validTemplateSlugs = new Set(templateConfigs.map((c: { slug: string }) => c.slug))
  for (const templateSlug of Object.keys(blocksByTemplate)) {
    if (!validTemplateSlugs.has(templateSlug)) {
      console.warn(`  Warning: Blocks reference unknown template "${templateSlug}"`)
    }
  }

  // Generate TypeScript file with pre-computed metadata
  const content = `// Auto-generated by scripts/build-registry.mts
// Do not edit this file directly.

/**
 * Pre-computed block category metadata for fast lookups
 * This avoids loading the full registry index (1.2MB) for navigation
 */

export const BLOCK_CATEGORIES: Record<string, string[]> = ${JSON.stringify(categoryStructure, null, 2)}

export function getAllCategories(): string[] {
  return Object.keys(BLOCK_CATEGORIES).sort()
}

export function getBlocksByCategory(category: string): string[] {
  return BLOCK_CATEGORIES[category] || []
}

export function getCategoryBlockCounts(): Record<string, number> {
  const counts: Record<string, number> = {}
  for (const [category, blocks] of Object.entries(BLOCK_CATEGORIES)) {
    counts[category] = blocks.length
  }
  return counts
}

/**
 * Template metadata for Full Pages section
 * Computed from _template-configs.ts (not registry items)
 */
export interface RegistryTemplateMetadata {
  slug: string
  name: string
  description: string
  heroBlock: string
  type: "service" | "application"
}

export const TEMPLATE_METADATA: RegistryTemplateMetadata[] = ${JSON.stringify(templateMetadata, null, 2)}

export function getAllTemplatesFromRegistry(): RegistryTemplateMetadata[] {
  return TEMPLATE_METADATA
}

export function getServiceTemplatesFromRegistry(): RegistryTemplateMetadata[] {
  return TEMPLATE_METADATA.filter((t) => t.type === "service")
}

export function getApplicationTemplatesFromRegistry(): RegistryTemplateMetadata[] {
  return TEMPLATE_METADATA.filter((t) => t.type === "application")
}

/**
 * Computed templates from blocks-first architecture
 * Each template aggregates blocks that belong to it via blockConfig
 */
export interface ComputedTemplateBlock {
  name: string
  blockType: string
  order: number
  palette: string
  typography: string
  tint?: "base" | "tinted" | "deep"
  forceLight?: boolean
  forceDark?: boolean
}

export interface ComputedTemplate {
  slug: string
  name: string
  description: string
  heroBlock: string
  type: "service" | "application"
  blocks: ComputedTemplateBlock[]
  blockGroups: Record<string, string[]> // blockType -> block names (for toggle UI)
}

export const COMPUTED_TEMPLATES: Record<string, ComputedTemplate> = ${JSON.stringify(computedTemplates, null, 2)}

export function getComputedTemplate(slug: string): ComputedTemplate | null {
  return COMPUTED_TEMPLATES[slug] || null
}

export function getAllComputedTemplates(): ComputedTemplate[] {
  return Object.values(COMPUTED_TEMPLATES)
}

export function getBlocksByTemplateAndType(slug: string, blockType: string): string[] {
  return COMPUTED_TEMPLATES[slug]?.blockGroups[blockType] || []
}
`

  const outputPath = path.join(process.cwd(), "registry/__blocks-metadata__.ts")
  rimraf.sync(outputPath)
  await fs.writeFile(outputPath, content)

  await new Promise<void>((resolve, reject) => {
    execFile('prettier', ['--write', outputPath], (error) => {
      if (error) reject(error)
      else resolve()
    })
  })

  const totalBlocks = Object.values(categoryStructure).flat().length
  console.log(`üìä Built blocks metadata: ${Object.keys(categoryStructure).length} categories, ${totalBlocks} blocks`)
  console.log(`üì¶ Computed ${Object.keys(computedTemplates).length} templates from blocks-first architecture`)
}

async function buildStylesIndex() {
  const payload = STYLES.map((style) => ({
    name: style.name,
    label: style.title,
  }))

  const outputPath = path.join(process.cwd(), "public/r/styles.json")
  await fs.writeFile(outputPath, JSON.stringify(payload, null, 2))

  await new Promise<void>((resolve, reject) => {
    execFile('prettier', ['--write', outputPath], (error) => {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  })
}

try {
  const styles = Array.from(STYLES)
  console.log(`üé® Found ${styles.length} styles: ${styles.map((s) => s.name).join(", ")}`)

  // Generate _registry.ts from .config.ts files
  console.log("\nüîß Generating _registry.ts from .config.ts files...")
  for (const style of styles) {
    console.log(`  Processing ${style.name}...`)
    await generateRegistryFromConfigs(style.name)
  }

  // Build unified multi-style index.
  console.log("\nüóÇÔ∏è Building unified multi-style registry/__index__.tsx...")
  await buildRegistryIndex(styles)

  for (const style of styles) {
    console.log(`\nüì¶ Processing style: ${style.name}`)

    console.log(`üíÖ Building registry-${style.name}.json...`)
    await buildRegistryJsonFile(style.name)

    console.log(`üèóÔ∏è Building registry for ${style.name}...`)
    await buildRegistry(style.name)
  }

  console.log("\nüóÇÔ∏è Building registry/__blocks__.json...")
  await buildBlocksIndex()

  console.log("\nüìä Building registry/__blocks-metadata__.ts...")
  await buildBlocksMetadata(styles)

  console.log("\nüé® Building public/r/styles.json...")
  await buildStylesIndex()

  // Clean up intermediate files.
  console.log("\nüßπ Cleaning up intermediate files...")
  for (const style of styles) {
    if (existsSync(path.join(process.cwd(), `registry-${style.name}.json`))) {
      await fs.unlink(path.join(process.cwd(), `registry-${style.name}.json`))
    }
  }

  // Run block screenshot capture if --capture flag is passed
  if (process.argv.includes("--capture")) {
    console.log("\nüì∏ Capturing block screenshots...")
    const captureResult = await new Promise<number>((resolve) => {
      const captureArgs = process.argv.includes("--force-capture")
        ? ["scripts/capture-blocks.mts", "--force"]
        : ["scripts/capture-blocks.mts"]
      const captureProcess = exec(`bun ${captureArgs.join(" ")}`)
      captureProcess.stdout?.pipe(process.stdout)
      captureProcess.stderr?.pipe(process.stderr)
      captureProcess.on("exit", (code) => resolve(code ?? 1))
    })
    if (captureResult !== 0) {
      console.warn("‚ö†Ô∏è  Screenshot capture failed (dev server may not be running)")
    }
  }

  console.log("\n‚úÖ Build complete!")
} catch (error) {
  console.error("‚ùå Build failed:", error instanceof Error ? error.message : String(error))
  if (error instanceof Error && error.stack) {
    console.error(error.stack)
  }
  process.exit(1)
}
