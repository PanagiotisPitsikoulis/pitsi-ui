import * as fs from "fs"
import * as path from "path"

const DEMO_BLOCKS_DIR = path.join(
  process.cwd(),
  "app/templates/_demo-blocks"
)

// Block types to scan (order matters for rendering)
const BLOCK_TYPES = [
  "hero",
  "features",
  "products",
  "pricing",
  "testimonials",
  "gallery",
  "team",
  "stats",
  "logos",
  "faq",
  "blog",
  "contact",
  "newsletter",
  "cta",
  "footer",
  "header",
] as const

type BlockType = (typeof BLOCK_TYPES)[number]

// Convert slug to PascalCase component name
function toPascalCase(str: string): string {
  return str
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("")
}

// Get component name for a block
function getComponentName(blockType: BlockType, variant: string): string {
  const prefix = toPascalCase(blockType)
  const suffix = toPascalCase(variant)
  return `${prefix}${suffix}`
}

// Scan a block type directory for all variants
function scanBlockType(blockType: BlockType): string[] {
  const blockDir = path.join(DEMO_BLOCKS_DIR, blockType)

  if (!fs.existsSync(blockDir)) {
    return []
  }

  const entries = fs.readdirSync(blockDir, { withFileTypes: true })
  const variants: string[] = []

  for (const entry of entries) {
    if (entry.isDirectory() && !entry.name.startsWith("_")) {
      const blockFile = path.join(blockDir, entry.name, `${blockType}.tsx`)
      if (fs.existsSync(blockFile)) {
        variants.push(entry.name)
      }
    }
  }

  return variants.sort()
}

// Generate index.ts content for a block type
function generateBlockIndex(blockType: BlockType, variants: string[]): string {
  const exports = variants.map((variant) => {
    const componentName = getComponentName(blockType, variant)
    return `export { ${componentName} } from "./${variant}/${blockType}"`
  })

  return `// ${toPascalCase(blockType)} block exports - Auto-generated
${exports.join("\n")}
`
}

// Build template registry mapping slugs to their available blocks
function buildTemplateRegistry(): Map<string, Map<BlockType, string[]>> {
  const registry = new Map<string, Map<BlockType, string[]>>()

  for (const blockType of BLOCK_TYPES) {
    const variants = scanBlockType(blockType)

    for (const variant of variants) {
      if (!registry.has(variant)) {
        registry.set(variant, new Map())
      }

      const templateBlocks = registry.get(variant)!
      if (!templateBlocks.has(blockType)) {
        templateBlocks.set(blockType, [])
      }
      templateBlocks.get(blockType)!.push(variant)
    }
  }

  return registry
}

// Generate the template registry TypeScript file
function generateTemplateRegistryFile(
  registry: Map<string, Map<BlockType, string[]>>
): string {
  const allVariants = new Set<string>()
  const blockTypeImports = new Map<BlockType, Set<string>>()

  // Collect all imports needed
  for (const [slug, blocks] of registry) {
    for (const [blockType, variants] of blocks) {
      if (!blockTypeImports.has(blockType)) {
        blockTypeImports.set(blockType, new Set())
      }
      for (const variant of variants) {
        const componentName = getComponentName(blockType, variant)
        blockTypeImports.get(blockType)!.add(componentName)
        allVariants.add(variant)
      }
    }
  }

  // Generate import statements
  const imports: string[] = []
  for (const blockType of BLOCK_TYPES) {
    const components = blockTypeImports.get(blockType)
    if (components && components.size > 0) {
      const sortedComponents = Array.from(components).sort()
      imports.push(`  // ${toPascalCase(blockType)} blocks`)
      for (const comp of sortedComponents) {
        imports.push(`  ${comp},`)
      }
    }
  }

  // Generate template configs
  const templateConfigs: string[] = []
  const sortedSlugs = Array.from(registry.keys()).sort()

  for (const slug of sortedSlugs) {
    const blocks = registry.get(slug)!
    const configParts: string[] = []

    for (const blockType of BLOCK_TYPES) {
      if (blocks.has(blockType)) {
        const variants = blocks.get(blockType)!
        if (variants.length === 1) {
          const componentName = getComponentName(blockType, variants[0])
          configParts.push(`    ${blockType}: ${componentName},`)
        } else {
          // Multiple variants - use array
          const componentNames = variants.map((v) => getComponentName(blockType, v))
          configParts.push(`    ${blockType}: [${componentNames.join(", ")}],`)
        }
      }
    }

    templateConfigs.push(`  "${slug}": {
${configParts.join("\n")}
  },`)
  }

  return `// Template Registry - Auto-generated by build-blocks-registry.mts
// Do not edit manually - run: bun run scripts/build-blocks-registry.mts

import type { ComponentType } from "react"

import {
${imports.join("\n")}
} from "../_demo-blocks"

import {
  heroThemes,
  type HeroTheme,
} from "../_demo-blocks/_themes"

// Block type definitions
export type BlockType = ${BLOCK_TYPES.map((t) => `"${t}"`).join(" | ")}

export interface TemplateConfig {
  theme?: HeroTheme
  mode?: "light" | "dark"
  hero?: ComponentType | ComponentType[]
  features?: ComponentType | ComponentType[]
  products?: ComponentType | ComponentType[]
  pricing?: ComponentType | ComponentType[]
  testimonials?: ComponentType | ComponentType[]
  gallery?: ComponentType | ComponentType[]
  team?: ComponentType | ComponentType[]
  stats?: ComponentType | ComponentType[]
  logos?: ComponentType | ComponentType[]
  faq?: ComponentType | ComponentType[]
  blog?: ComponentType | ComponentType[]
  contact?: ComponentType | ComponentType[]
  newsletter?: ComponentType | ComponentType[]
  cta?: ComponentType | ComponentType[]
  footer?: ComponentType | ComponentType[]
  header?: ComponentType | ComponentType[]
}

// Get theme for a template slug
function getThemeForSlug(slug: string): HeroTheme {
  const themeMap: Record<string, keyof typeof heroThemes> = {
    "ai": "ai",
    "ai-sci-fi": "aiSciFi",
    "art": "art",
    "boat": "boat",
    "food-juice": "juice",
    "food-pizza": "pizza",
    "product-coffee": "coffee",
    "product-plants": "plants",
    "product-scifi": "tech",
    "product-skincare": "skincare",
    "service-barber": "barber",
    "service-coffee-shop": "coffee",
    "service-fashion": "fashion",
    "service-gym": "gym",
    "service-hospitality": "hospitality",
    "service-makeup": "makeup",
    "service-marketing": "marketing",
    "service-pet-sitting": "petSitting",
    "service-plants": "plants",
    "service-psychologist": "therapy",
    "service-real-estate": "realEstate",
    "service-tattoo": "tattoo",
  }

  const themeKey = themeMap[slug] || "ai"
  return heroThemes[themeKey]
}

// Template configurations
const templateBlocksConfig: Record<string, Omit<TemplateConfig, "theme" | "mode">> = {
${templateConfigs.join("\n")}
}

// Export full template configs with themes
export const templateConfigs: Record<string, TemplateConfig> = Object.fromEntries(
  Object.entries(templateBlocksConfig).map(([slug, config]) => [
    slug,
    {
      theme: getThemeForSlug(slug),
      mode: "dark" as const,
      ...config,
    },
  ])
)

// Get all available template slugs
export const templateSlugs = Object.keys(templateConfigs)

// Block rendering order
export const blockRenderOrder: BlockType[] = [
  "header",
  "hero",
  "features",
  "products",
  "pricing",
  "testimonials",
  "gallery",
  "team",
  "stats",
  "logos",
  "faq",
  "blog",
  "contact",
  "newsletter",
  "cta",
  "footer",
]
`
}

async function main() {
  console.log("ðŸ” Scanning demo blocks directory...")

  // Update each block type's index.ts
  for (const blockType of BLOCK_TYPES) {
    const variants = scanBlockType(blockType)

    if (variants.length > 0) {
      const indexPath = path.join(DEMO_BLOCKS_DIR, blockType, "index.ts")
      const indexContent = generateBlockIndex(blockType, variants)
      fs.writeFileSync(indexPath, indexContent)
      console.log(`âœ… Updated ${blockType}/index.ts (${variants.length} variants)`)
    }
  }

  // Build and write template registry
  console.log("\nðŸ“¦ Building template registry...")
  const registry = buildTemplateRegistry()
  const registryContent = generateTemplateRegistryFile(registry)

  const registryPath = path.join(
    process.cwd(),
    "app/templates/_demo-blocks/_registry/template-registry.ts"
  )

  // Create directory if needed
  fs.mkdirSync(path.dirname(registryPath), { recursive: true })
  fs.writeFileSync(registryPath, registryContent)
  console.log(`âœ… Created template-registry.ts`)

  // Create _registry/index.ts
  const registryIndexPath = path.join(
    process.cwd(),
    "app/templates/_demo-blocks/_registry/index.ts"
  )
  fs.writeFileSync(
    registryIndexPath,
    `export * from "./template-registry"\n`
  )
  console.log(`âœ… Created _registry/index.ts`)

  console.log(`\nâœ¨ Done! Found ${registry.size} templates`)
  console.log("\nTemplate coverage:")
  for (const [slug, blocks] of Array.from(registry.entries()).sort()) {
    const blockList = Array.from(blocks.keys()).join(", ")
    console.log(`  ${slug}: ${blockList}`)
  }
}

main().catch(console.error)
