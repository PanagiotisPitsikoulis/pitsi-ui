# Registry Config Files Design

## Overview

Refactor the registry system so that each block component has a co-located `.config.ts` file exporting its registry configuration. The build script dynamically generates `_registry.ts` files from these distributed configs.

## Goals

- **Colocation**: Keep registry metadata next to the component it describes
- **Discoverability**: Easy to find and edit a block's configuration
- **Type safety**: Shared `RegistryItemConfig` type with autocomplete
- **Clean separation**: Templates remain in a dedicated `_templates.ts` file

## Design

### 1. Config File Format

Each block component has a sibling `.config.ts` file:

```typescript
// apps/v4/registry/new-york-v4/blocks/hero/hero-1.config.ts
import type { RegistryItemConfig } from "@/registry/types"

export const registryConfig: RegistryItemConfig = {
  name: "hero-1",
  type: "registry:block",
  description: "Plant shop hero section with parallax effects and knockout text",
  dependencies: ["motion/react"],
  registryDependencies: ["button", "hero-button", "spacer"],
  categories: ["hero", "landing"],
  tier: "free",
  readiness: "production",
  blockConfig: {
    template: "service-plants",
    blockType: "hero",
    order: 2,
    palette: "sage",
    typography: "elegant",
    tint: "tinted",
    forceLight: true,
  },
}
```

Key points:
- The `files` array is omitted - inferred from config file location
- The `bc()` helper is replaced with inline objects
- Shared type provides autocomplete and validation

### 2. Directory Structure

```
blocks/hero/
├── hero-1.tsx           # Component
├── hero-1.config.ts     # Config
├── hero-2.tsx
├── hero-2.config.ts
└── ...
```

### 3. File Discovery

The build script discovers all `.config.ts` files and infers component paths:

```typescript
const configFiles = await glob("registry/new-york-v4/**/*.config.ts")

for (const configPath of configFiles) {
  const componentPath = configPath
    .replace("registry/new-york-v4/", "")
    .replace(".config.ts", ".tsx")

  const { registryConfig } = await import(configPath)

  const files = [{
    path: componentPath,
    type: registryConfig.type,
  }]
}
```

### 4. Generated `_registry.ts`

The build script generates `_registry.ts` per style:

```typescript
// AUTO-GENERATED by scripts/build-registry.mts
// Do not edit this file directly.
import { Registry } from "pitsi/schema"

export const blocks: Registry["items"] = [
  {
    name: "hero-1",
    type: "registry:block",
    description: "Plant shop hero section with parallax effects",
    dependencies: ["motion/react"],
    registryDependencies: ["button", "hero-button", "spacer"],
    files: [{ path: "blocks/hero/hero-1.tsx", type: "registry:block" }],
    categories: ["hero", "landing"],
    tier: "free",
    readiness: "production",
    blockConfig: {
      template: "service-plants",
      blockType: "hero",
      order: 2,
      palette: "sage",
      typography: "elegant",
      tint: "tinted",
      forceLight: true,
    },
  },
  // ... all other blocks
]
```

- Sorted alphabetically by name for consistent diffs
- Generated fresh each build (no incremental updates)

### 5. Template Handling

Templates remain in a manually maintained `_templates.ts` file:

```typescript
// apps/v4/registry/new-york-v4/blocks/_templates.ts
import { Registry } from "pitsi/schema"

export const templates: Registry["items"] = [
  {
    name: "service-plants",
    type: "registry:block",
    description: "Complete plant shop landing page template",
    registryDependencies: ["header-1", "hero-1", ...],
    files: [{ path: "blocks/service/service-plants.tsx", type: "registry:block" }],
    categories: ["template", "service"],
    tier: "free",
    readiness: "production",
    meta: { heroBlock: "hero-1" },
  },
  // other templates...
]
```

The main `registry.ts` merges both:

```typescript
import { blocks } from "./blocks/_registry"
import { templates } from "./blocks/_templates"

export const registry = {
  name: "new-york-v4",
  items: [...blocks, ...templates],
}
```

### 6. Build Script Changes

Add `generateRegistryFromConfigs()` to `build-registry.mts`:

```typescript
async function generateRegistryFromConfigs(styleName: string) {
  const configPattern = `registry/${styleName}/**/*.config.ts`
  const configFiles = await glob(configPattern)

  const items: RegistryItem[] = []

  for (const configPath of configFiles) {
    const { registryConfig } = await import(configPath)

    const componentPath = configPath
      .replace(`registry/${styleName}/`, "")
      .replace(".config.ts", ".tsx")

    items.push({
      ...registryConfig,
      files: [{ path: componentPath, type: registryConfig.type }],
    })
  }

  items.sort((a, b) => a.name.localeCompare(b.name))

  const output = generateRegistryFile(items)
  await fs.writeFile(`registry/${styleName}/blocks/_registry.ts`, output)
}
```

Build order:
1. `generateRegistryFromConfigs()` - creates `_registry.ts` from configs
2. Existing `buildRegistryIndex()` - creates `__index__.tsx`
3. Existing `buildRegistryJsonFile()` - creates `registry.json`
4. Rest of pipeline unchanged

## Migration Plan

1. Create `registry/types.ts` with `RegistryItemConfig` type
2. Add `generateRegistryFromConfigs()` to build script
3. Extract templates to `blocks/_templates.ts`
4. Write migration script to generate `.config.ts` files from current `_registry.ts`
5. Run migration script to create all config files
6. Verify build produces identical output
7. Update `_registry.ts` to be auto-generated (remove manual entries)
8. Delete `BlockConfig` interface and `bc()` helper

## Files Changed

| File | Change |
|------|--------|
| `registry/types.ts` | New - `RegistryItemConfig` type |
| `scripts/build-registry.mts` | Add `generateRegistryFromConfigs()` |
| `blocks/_templates.ts` | New - extracted template entries |
| `blocks/_registry.ts` | Becomes auto-generated |
| `~180 .config.ts` files | New - one per block component |
