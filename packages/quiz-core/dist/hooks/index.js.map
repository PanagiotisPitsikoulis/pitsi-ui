{"version":3,"sources":["../../src/hooks/use-quiz.ts","../../src/utils/scoring.ts"],"sourcesContent":["\"use client\"\n\nimport { useCallback, useReducer } from \"react\"\n\nimport type { Quiz, QuizAction, QuizResult, QuizState, UserAnswer } from \"../types\"\nimport { calculateQuizResult, prepareQuiz } from \"../utils\"\n\nconst initialState: QuizState = {\n  quiz: null,\n  currentQuestionIndex: 0,\n  userAnswers: [],\n  isStarted: false,\n  isCompleted: false,\n  startTime: null,\n  result: null,\n}\n\nfunction quizReducer(state: QuizState, action: QuizAction): QuizState {\n  switch (action.type) {\n    case \"LOAD_QUIZ\":\n      return {\n        ...initialState,\n        quiz: prepareQuiz(action.quiz),\n      }\n\n    case \"START_QUIZ\":\n      return {\n        ...state,\n        isStarted: true,\n        startTime: new Date(),\n      }\n\n    case \"ANSWER_QUESTION\": {\n      const existingIndex = state.userAnswers.findIndex(\n        (a) => a.questionId === action.questionId\n      )\n\n      const newAnswer: UserAnswer = {\n        questionId: action.questionId,\n        selectedAnswerIds: action.answerIds,\n        textAnswer: action.textAnswer,\n      }\n\n      const newAnswers =\n        existingIndex >= 0\n          ? state.userAnswers.map((a, i) => (i === existingIndex ? newAnswer : a))\n          : [...state.userAnswers, newAnswer]\n\n      return {\n        ...state,\n        userAnswers: newAnswers,\n      }\n    }\n\n    case \"NEXT_QUESTION\":\n      if (!state.quiz) return state\n      return {\n        ...state,\n        currentQuestionIndex: Math.min(\n          state.currentQuestionIndex + 1,\n          state.quiz.questions.length - 1\n        ),\n      }\n\n    case \"PREVIOUS_QUESTION\":\n      return {\n        ...state,\n        currentQuestionIndex: Math.max(state.currentQuestionIndex - 1, 0),\n      }\n\n    case \"GO_TO_QUESTION\":\n      if (!state.quiz) return state\n      return {\n        ...state,\n        currentQuestionIndex: Math.max(\n          0,\n          Math.min(action.index, state.quiz.questions.length - 1)\n        ),\n      }\n\n    case \"COMPLETE_QUIZ\": {\n      if (!state.quiz || !state.startTime) return state\n\n      const result = calculateQuizResult(\n        state.quiz,\n        state.userAnswers,\n        state.startTime\n      )\n\n      return {\n        ...state,\n        isCompleted: true,\n        result,\n      }\n    }\n\n    case \"RESET_QUIZ\":\n      return state.quiz\n        ? {\n            ...initialState,\n            quiz: prepareQuiz(state.quiz),\n          }\n        : initialState\n\n    default:\n      return state\n  }\n}\n\nexport interface UseQuizOptions {\n  onComplete?: (result: QuizResult) => void\n}\n\nexport function useQuiz(options: UseQuizOptions = {}) {\n  const [state, dispatch] = useReducer(quizReducer, initialState)\n\n  const loadQuiz = useCallback((quiz: Quiz) => {\n    dispatch({ type: \"LOAD_QUIZ\", quiz })\n  }, [])\n\n  const startQuiz = useCallback(() => {\n    dispatch({ type: \"START_QUIZ\" })\n  }, [])\n\n  const answerQuestion = useCallback(\n    (questionId: string, answerIds: string[], textAnswer?: string) => {\n      dispatch({ type: \"ANSWER_QUESTION\", questionId, answerIds, textAnswer })\n    },\n    []\n  )\n\n  const nextQuestion = useCallback(() => {\n    dispatch({ type: \"NEXT_QUESTION\" })\n  }, [])\n\n  const previousQuestion = useCallback(() => {\n    dispatch({ type: \"PREVIOUS_QUESTION\" })\n  }, [])\n\n  const goToQuestion = useCallback((index: number) => {\n    dispatch({ type: \"GO_TO_QUESTION\", index })\n  }, [])\n\n  const completeQuiz = useCallback(() => {\n    dispatch({ type: \"COMPLETE_QUIZ\" })\n    // Call onComplete callback if result is available\n    if (state.quiz && state.startTime) {\n      const result = calculateQuizResult(state.quiz, state.userAnswers, state.startTime)\n      options.onComplete?.(result)\n    }\n  }, [state.quiz, state.userAnswers, state.startTime, options])\n\n  const resetQuiz = useCallback(() => {\n    dispatch({ type: \"RESET_QUIZ\" })\n  }, [])\n\n  // Derived values\n  const currentQuestion = state.quiz?.questions[state.currentQuestionIndex] ?? null\n  const currentAnswer = state.userAnswers.find(\n    (a) => a.questionId === currentQuestion?.id\n  )\n  const totalQuestions = state.quiz?.questions.length ?? 0\n  const answeredCount = state.userAnswers.length\n  const progress = totalQuestions > 0 ? (answeredCount / totalQuestions) * 100 : 0\n  const isLastQuestion = state.currentQuestionIndex === totalQuestions - 1\n  const isFirstQuestion = state.currentQuestionIndex === 0\n  const canComplete = answeredCount === totalQuestions\n\n  return {\n    // State\n    quiz: state.quiz,\n    currentQuestionIndex: state.currentQuestionIndex,\n    currentQuestion,\n    currentAnswer,\n    userAnswers: state.userAnswers,\n    isStarted: state.isStarted,\n    isCompleted: state.isCompleted,\n    startTime: state.startTime,\n    result: state.result,\n\n    // Derived\n    totalQuestions,\n    answeredCount,\n    progress,\n    isLastQuestion,\n    isFirstQuestion,\n    canComplete,\n\n    // Actions\n    loadQuiz,\n    startQuiz,\n    answerQuestion,\n    nextQuestion,\n    previousQuestion,\n    goToQuestion,\n    completeQuiz,\n    resetQuiz,\n  }\n}\n","import type { Question, Quiz, QuizResult, UserAnswer } from \"../types\"\n\n/**\n * Calculate the score for a single question\n */\nexport function calculateQuestionScore(\n  question: Question,\n  userAnswer: UserAnswer | undefined\n): { isCorrect: boolean; points: number } {\n  if (!userAnswer) {\n    return { isCorrect: false, points: 0 }\n  }\n\n  const correctAnswerIds = question.answers\n    .filter((a) => a.isCorrect)\n    .map((a) => a.id)\n\n  // For text input, we can't auto-grade (needs manual review)\n  if (question.type === \"text_input\") {\n    return { isCorrect: false, points: 0 }\n  }\n\n  // Check if user's answers match correct answers exactly\n  const userAnswerIds = new Set(userAnswer.selectedAnswerIds)\n  const correctIds = new Set(correctAnswerIds)\n\n  const isCorrect =\n    userAnswerIds.size === correctIds.size &&\n    [...userAnswerIds].every((id) => correctIds.has(id))\n\n  return {\n    isCorrect,\n    points: isCorrect ? question.points : 0,\n  }\n}\n\n/**\n * Calculate the total quiz result\n */\nexport function calculateQuizResult(\n  quiz: Quiz,\n  userAnswers: UserAnswer[],\n  startTime: Date\n): QuizResult {\n  const answerMap = new Map(userAnswers.map((a) => [a.questionId, a]))\n\n  let correctAnswers = 0\n  let earnedPoints = 0\n  const totalPoints = quiz.questions.reduce((sum, q) => sum + q.points, 0)\n\n  for (const question of quiz.questions) {\n    const result = calculateQuestionScore(question, answerMap.get(question.id))\n    if (result.isCorrect) {\n      correctAnswers++\n    }\n    earnedPoints += result.points\n  }\n\n  const percentage = totalPoints > 0 ? (earnedPoints / totalPoints) * 100 : 0\n  const passed = quiz.passingScore ? percentage >= quiz.passingScore : true\n  const timeSpent = Math.floor((new Date().getTime() - startTime.getTime()) / 1000)\n\n  return {\n    quizId: quiz.id,\n    totalQuestions: quiz.questions.length,\n    correctAnswers,\n    totalPoints,\n    earnedPoints,\n    percentage,\n    passed,\n    timeSpent,\n    answers: userAnswers,\n    completedAt: new Date(),\n  }\n}\n\n/**\n * Shuffle an array using Fisher-Yates algorithm\n */\nexport function shuffleArray<T>(array: T[]): T[] {\n  const shuffled = [...array]\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    ;[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]\n  }\n  return shuffled\n}\n\n/**\n * Prepare quiz by optionally shuffling questions and answers\n */\nexport function prepareQuiz(quiz: Quiz): Quiz {\n  let questions = [...quiz.questions]\n\n  if (quiz.shuffleQuestions) {\n    questions = shuffleArray(questions)\n  }\n\n  if (quiz.shuffleAnswers) {\n    questions = questions.map((q) => ({\n      ...q,\n      answers: shuffleArray(q.answers),\n    }))\n  }\n\n  return {\n    ...quiz,\n    questions,\n  }\n}\n\n/**\n * Format time in seconds to mm:ss string\n */\nexport function formatTime(seconds: number): string {\n  const mins = Math.floor(seconds / 60)\n  const secs = seconds % 60\n  return `${mins.toString().padStart(2, \"0\")}:${secs.toString().padStart(2, \"0\")}`\n}\n\n/**\n * Get progress percentage\n */\nexport function getProgressPercentage(\n  currentIndex: number,\n  totalQuestions: number\n): number {\n  if (totalQuestions === 0) return 0\n  return ((currentIndex + 1) / totalQuestions) * 100\n}\n"],"mappings":"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","names":[]}